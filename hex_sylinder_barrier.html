<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hex Cylinder Tapered Lattice – Three.js Demo</title>
  <style>
    html,body{height:100%;margin:0;background:#05070a;color:#e6eef8;font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"}
    #app{position:fixed;inset:0}
    .hud{position:fixed;left:12px;bottom:12px;font-size:12px;opacity:.85;line-height:1.5}
    .tests{position:fixed;right:12px;top:12px;background:#0b1420cc;border:1px solid #1e3350;border-radius:10px;padding:10px 12px;font-size:12px;box-shadow:0 6px 20px #00000055}
    .tests h3{margin:.2em 0 .4em 0;font-size:12px;font-weight:700;color:#cfe8ff}
    .tests ul{list-style:none;margin:0;padding:0}
    .tests li{margin:.2em 0;padding:0}
    .ok{color:#9ff29f}
    .ng{color:#ffb3b3}
    a{color:#a8d1ff}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">円筒ラティスから球へ絞り込んだ六角形バリア<br/>クリック＆ドラッグで視点回転（ホイールでズーム）</div>
  <div class="tests" id="tests"><h3>Self‑Tests</h3><ul id="test-list"><li>Running…</li></ul></div>

  <script type="module">
    // NOTE: modules loaded from esm.sh CDN so dependencies resolve without import maps
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // ===== helpers for inline tests =====
    const testsEl = document.getElementById('test-list');
    function report(name, pass, detail=""){
      const li = document.createElement('li');
      li.className = pass ? 'ok' : 'ng';
      li.textContent = `${pass ? '✔' : '✖'} ${name}${detail ? ' — ' + detail : ''}`;
      testsEl.appendChild(li);
      if(!pass){ console.error('[TEST FAIL]', name, detail); }
    }
    function clearTests(){ testsEl.innerHTML = ''; }

    // ===== scene =====
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('app').appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 8);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // lighting
    const light1 = new THREE.DirectionalLight(0xffffff, 0.8); light1.position.set(3,2,4); scene.add(light1);
    const amb = new THREE.AmbientLight(0x88aaff, 0.35); scene.add(amb);

    // ===== parameters =====
    const CYLINDER_RADIUS = 2.2;
    const HEX_SIZE = 0.3;

    const CYL_HEIGHT = Math.PI * CYLINDER_RADIUS;
    const HALF_HEIGHT = CYL_HEIGHT * 0.5;
    const CIRCUMFERENCE = 2 * Math.PI * CYLINDER_RADIUS;

    const BASE_HORIZONTAL_SPACING = Math.sqrt(3) * HEX_SIZE;
    const BASE_VERTICAL_SPACING = HEX_SIZE * 1.5;

    const NUM_HEX_AROUND = Math.max(6, Math.round(CIRCUMFERENCE / BASE_HORIZONTAL_SPACING));
    const ACTUAL_HORIZONTAL_SPACING = CIRCUMFERENCE / NUM_HEX_AROUND;
    const HORIZONTAL_SCALE = ACTUAL_HORIZONTAL_SPACING / BASE_HORIZONTAL_SPACING;
    const ANGLE_STEP = ACTUAL_HORIZONTAL_SPACING / CYLINDER_RADIUS;

    const NUM_ROWS_ESTIMATE = Math.max(1, Math.round((CYL_HEIGHT - 2 * HEX_SIZE) / BASE_VERTICAL_SPACING) + 1);
    const verticalDenominator = (NUM_ROWS_ESTIMATE - 1) * BASE_VERTICAL_SPACING + 2 * HEX_SIZE;
    const BASE_VERTICAL_SCALE = CYL_HEIGHT / Math.max(verticalDenominator, 1e-6);

    const VERTICAL_SHRINK = 0.35;
    const RADIUS_SHRINK = 0.4;
    const SPHERE_RADIUS = CYLINDER_RADIUS;
    const TAPER_RADIUS = CYLINDER_RADIUS;

    // ===== Create polygons =====
    const group = new THREE.Group();
    scene.add(group);

    const hexMat = new THREE.LineBasicMaterial({ color: 0x89f0ff });
    const hexMatBack = new THREE.LineBasicMaterial({ color: 0x2a484d });

    const hexFaceFrontMat = new THREE.MeshStandardMaterial({
      color: 0x52e4ff, emissive: 0x154d72, emissiveIntensity: 0.9, roughness: 0.3, metalness: 0.35, transparent: true, opacity: 0.85, side: THREE.FrontSide,
      polygonOffset: true, polygonOffsetFactor: -1.0, polygonOffsetUnits: -1.0
    });
    const hexFaceBackMat = new THREE.MeshStandardMaterial({
      color: 0x0d2436, emissive: 0x081523, emissiveIntensity: 0.35, roughness: 0.8, metalness: 0.05, transparent: true, opacity: 0.1, side: THREE.BackSide,
      polygonOffset: true, polygonOffsetFactor: 1.0, polygonOffsetUnits: 1.0
    });

    let hexCount = 0;
    const polygons = [];

    function verticalScaleAt(yNorm) {
      const falloff = Math.pow(1 - Math.min(1, Math.abs(yNorm)), 1.5);
      return THREE.MathUtils.lerp(VERTICAL_SHRINK, 1.0, falloff);
    }

    function radiusScaleAt(yNorm) {
      const smooth = THREE.MathUtils.smoothstep(Math.abs(yNorm), 0, 1);
      const shrink = 1 - RADIUS_SHRINK * smooth;
      return Math.max(0.12, shrink);
    }

    function mapToSphere(x, y, z) {
      const radial = Math.sqrt(x * x + z * z);
      if (radial < 1e-6) {
        return new THREE.Vector3(0, THREE.MathUtils.clamp(y, -SPHERE_RADIUS, SPHERE_RADIUS), 0);
      }
      const lat = (Math.PI * y) / CYL_HEIGHT;
      const projectedRadius = SPHERE_RADIUS * Math.cos(lat);
      const newY = SPHERE_RADIUS * Math.sin(lat);
      const scale = projectedRadius / radial;
      return new THREE.Vector3(x * scale, newY, z * scale);
    }

    function createHexRow(rowInfo) {
      const centerY = rowInfo.y;
      const yNorm = centerY / HALF_HEIGHT;
      const verticalScale = verticalScaleAt(yNorm);
      const radiusScale = radiusScaleAt(yNorm);
      const effectiveRadius = TAPER_RADIUS * radiusScale;
      const parity = rowInfo.index & 1;
      const offset = parity ? 0.5 : 0.0;

      for (let q = 0; q < NUM_HEX_AROUND; q++) {
        const angleCenter = (q + offset) * ANGLE_STEP;

        const centerVec = new THREE.Vector3(
          effectiveRadius * Math.cos(angleCenter),
          centerY,
          effectiveRadius * Math.sin(angleCenter)
        );

        const pts = [];
        for (let i = 0; i < 6; i++) {
          const cornerAngle = Math.PI / 6 + (Math.PI / 3) * i;
          const tangentialOffset = HEX_SIZE * Math.cos(cornerAngle) * HORIZONTAL_SCALE * radiusScale;
          const verticalOffset = HEX_SIZE * Math.sin(cornerAngle) * BASE_VERTICAL_SCALE * verticalScale;

          const theta = angleCenter + (tangentialOffset / Math.max(effectiveRadius, 1e-6));
          const y = centerY + verticalOffset;

          if (Math.abs(y) > HALF_HEIGHT + 1e-5) {
            pts.length = 0;
            break;
          }

          const cylinderPoint = new THREE.Vector3(
            effectiveRadius * Math.cos(theta),
            y,
            effectiveRadius * Math.sin(theta)
          );
          const spherePoint = mapToSphere(cylinderPoint.x, cylinderPoint.y, cylinderPoint.z);
          pts.push(spherePoint);
        }

        if (pts.length < 6) continue;

        const faceCenter = new THREE.Vector3();
        for (const p of pts) faceCenter.add(p);
        faceCenter.divideScalar(pts.length);
        hexCount++;

        const triPositions = new Float32Array(pts.length * 9);
        for (let i = 0; i < pts.length; i++) {
          const curr = pts[i];
          const next = pts[(i + 1) % pts.length];
          const off = i * 9;
          triPositions.set([faceCenter.x, faceCenter.y, faceCenter.z], off);
          triPositions.set([curr.x, curr.y, curr.z], off + 3);
          triPositions.set([next.x, next.y, next.z], off + 6);
        }
        const faceGeom = new THREE.BufferGeometry();
        faceGeom.setAttribute('position', new THREE.BufferAttribute(triPositions, 3));
        faceGeom.computeVertexNormals();

        const frontMesh = new THREE.Mesh(faceGeom, hexFaceFrontMat);
        const backMesh = new THREE.Mesh(faceGeom, hexFaceBackMat);
        backMesh.renderOrder = 0;
        frontMesh.renderOrder = 1;
        group.add(backMesh, frontMesh);

        const geom = new THREE.BufferGeometry().setFromPoints(pts);
        const loop = new THREE.LineLoop(geom, hexMat);
        loop.renderOrder = 4;
        group.add(loop);

        const normal = faceCenter.clone().normalize();
        polygons.push({ line: loop, normal: normal });
      }
    }

    const rows = [];
    let rowIndex = 0;
    let currentY = -HALF_HEIGHT + HEX_SIZE * BASE_VERTICAL_SCALE * verticalScaleAt(-1);

    while (rowIndex < 2048) {
      const yNorm = currentY / HALF_HEIGHT;
      const localScale = verticalScaleAt(yNorm);
      const halfHexHeight = HEX_SIZE * BASE_VERTICAL_SCALE * localScale;
      if (currentY + halfHexHeight > HALF_HEIGHT + 1e-5) {
        break;
      }

      rows.push({ y: currentY, index: rowIndex });
      const spacing = BASE_VERTICAL_SPACING * BASE_VERTICAL_SCALE * localScale;
      currentY += spacing;
      rowIndex++;
    }

    rows.forEach(createHexRow);

    // ===== Self tests =====
    clearTests();
    report('Modules loaded', !!THREE && !!OrbitControls);
    report('Renderer created', !!renderer && !!renderer.domElement);
    report('Hexagons created', hexCount > 0, `n=${hexCount}`);

    // ===== animation =====
    let t = 0;
    const camWorldPos = new THREE.Vector3();

    function animate(){
      requestAnimationFrame(animate);
      t += 0.0025;
      group.rotation.y = t * 0.2;
      group.rotation.x = t * 0.1;
      controls.update();

      camera.getWorldPosition(camWorldPos);
      const groupWorldPos = group.position;
      const viewDir = camWorldPos.sub(groupWorldPos).normalize();

      for (const poly of polygons) {
        const worldNormal = poly.normal.clone().applyQuaternion(group.quaternion);
        const dot = worldNormal.dot(viewDir);

        if (dot > 0) { // Facing towards camera (front side)
          poly.line.material = hexMat;
        } else { // Facing away from camera (back side)
          poly.line.material = hexMatBack;
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>

  <script>
    // Friendly hints for common pitfalls
    (function(){
      const canvas = document.createElement('canvas');
      if (!canvas.getContext('webgl2') && !canvas.getContext('webgl')) {
        console.warn('[Hint] このブラウザ/環境では WebGL が無効なためレンダリングできません。ブラウザ設定やGPUドライバをご確認ください。');
      }
      if (location.protocol === 'file:') {
        console.info('[Hint] file:// で開いても動きますが、CORSや拡張機能の干渉があると失敗することがあります。うまくいかない場合は簡易HTTPサーバで開いてください (例: `python3 -m http.server`).');
      }
    })();
  </script>
</body>
</html>
