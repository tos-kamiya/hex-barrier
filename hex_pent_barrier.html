<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hex+Pent Barrier – Three.js Demo</title>
  <style>
    html,body{height:100%;margin:0;background:#05070a;color:#e6eef8;font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"}
    #app{position:fixed;inset:0}
    .hud{position:fixed;left:12px;bottom:12px;font-size:12px;opacity:.85;line-height:1.5}
    .tests{position:fixed;right:12px;top:12px;background:#0b1420cc;border:1px solid #1e3350;border-radius:10px;padding:10px 12px;font-size:12px;box-shadow:0 6px 20px #00000055}
    .tests h3{margin:.2em 0 .4em 0;font-size:12px;font-weight:700;color:#cfe8ff}
    .tests ul{list-style:none;margin:0;padding:0}
    .tests li{margin:.2em 0;padding:0}
    .ok{color:#9ff29f}
    .ng{color:#ffb3b3}
    a{color:#a8d1ff}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">六角形主体＋12個の五角形セルを持つ“バリア”ネット<br/>クリック＆ドラッグで視点回転（ホイールでズーム）</div>
  <div class="tests" id="tests"><h3>Self‑Tests</h3><ul id="test-list"><li>Running…</li></ul></div>

  <script type="module">
    // NOTE: modules loaded from esm.sh CDN so dependencies resolve without import maps
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // ===== helpers for inline tests =====
    const testsEl = document.getElementById('test-list');
    function report(name, pass, detail=""){
      const li = document.createElement('li');
      li.className = pass ? 'ok' : 'ng';
      li.textContent = `${pass ? '✔' : '✖'} ${name}${detail ? ' — ' + detail : ''}`;
      testsEl.appendChild(li);
      if(!pass){ console.error('[TEST FAIL]', name, detail); }
    }
    function clearTests(){ testsEl.innerHTML = ''; }

    // ===== scene =====
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('app').appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 6);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // lighting
    const light1 = new THREE.DirectionalLight(0xffffff, 0.8); light1.position.set(3,2,4); scene.add(light1);
    const amb = new THREE.AmbientLight(0x88aaff, 0.35); scene.add(amb);

    // ===== parameters =====
    const RADIUS = 2.0;   // sphere radius
    const DETAIL = 3;     // icosahedron subdivision detail (>=2 推奨)

    // ===== build geodesic sphere (triangles) =====
    const baseGeo = new THREE.IcosahedronGeometry(RADIUS, DETAIL);
    baseGeo.computeVertexNormals();

    // ensure vertices lie exactly on sphere
    {
      const pos = baseGeo.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const v = new THREE.Vector3().fromBufferAttribute(pos, i).normalize().multiplyScalar(RADIUS);
        pos.setXYZ(i, v.x, v.y, v.z);
      }
      pos.needsUpdate = true;
    }

    const posAttr = baseGeo.attributes.position;
    const vertices = [];
    let index = baseGeo.index ? Array.from(baseGeo.index.array) : null;

    if (index) {
      for (let i = 0; i < posAttr.count; i++) {
        vertices.push(new THREE.Vector3().fromBufferAttribute(posAttr, i));
      }
    } else {
      const keyToIndex = new Map();
      index = [];
      for (let i = 0; i < posAttr.count; i++) {
        const v = new THREE.Vector3().fromBufferAttribute(posAttr, i);
        const key = `${v.x.toFixed(6)},${v.y.toFixed(6)},${v.z.toFixed(6)}`;
        let mapped = keyToIndex.get(key);
        if (mapped === undefined) {
          mapped = vertices.length;
          keyToIndex.set(key, mapped);
          vertices.push(v);
        }
        index.push(mapped);
      }
    }

    const getV = (i) => vertices[i].clone();

    const faceCentroids = []; // triangle centroids on sphere
    for (let f = 0; f < index.length; f += 3) {
      const a = getV(index[f]);
      const b = getV(index[f+1]);
      const c = getV(index[f+2]);
      const centroid = new THREE.Vector3().add(a).add(b).add(c).multiplyScalar(1/3).normalize().multiplyScalar(RADIUS);
      faceCentroids.push(centroid);
    }

    // vertex -> incident triangle indices
    const vertexToFaces = new Map();
    for (let fi = 0, tri = 0; fi < index.length; fi += 3, tri++) {
      for (let k = 0; k < 3; k++) {
        const vi = index[fi + k];
        if (!vertexToFaces.has(vi)) vertexToFaces.set(vi, []);
        vertexToFaces.get(vi).push(tri);
      }
    }

    // Sort incident faces around a vertex to make a CCW polygon (LineLoop)
    const sortFacesAroundVertex = (vertexIndex) => {
      const v = getV(vertexIndex).clone().normalize();
      const faces = vertexToFaces.get(vertexIndex);
      const up = v.clone();
      const tmp = Math.abs(up.y) < 0.9 ? new THREE.Vector3(0,1,0) : new THREE.Vector3(1,0,0);
      const tangent = new THREE.Vector3().crossVectors(tmp, up).normalize();
      const bitangent = new THREE.Vector3().crossVectors(up, tangent).normalize();
      const items = faces.map(fi => {
        const c = faceCentroids[fi];
        const d = c.clone().sub(up.clone().multiplyScalar(c.clone().dot(up))); // project to tangent plane
        const x = d.dot(tangent);
        const y = d.dot(bitangent);
        const ang = Math.atan2(y, x);
        return { fi, ang };
      });
      items.sort((a,b) => a.ang - b.ang);
      return items.map(it => it.fi);
    };

    // ===== Create polygons (dual mesh): mostly hexagons, 12 pentagons =====
    const group = new THREE.Group();
    scene.add(group);

    const hexMat = new THREE.LineBasicMaterial({ color: 0x89f0ff });
    const pentMat = new THREE.LineBasicMaterial({ color: 0xffd29a });
    const hexMatBack = new THREE.LineBasicMaterial({ color: 0x2a484d });
    const pentMatBack = new THREE.LineBasicMaterial({ color: 0x4d3e2e });

    const hexFaceFrontMat = new THREE.MeshStandardMaterial({
      color: 0x52e4ff, emissive: 0x154d72, emissiveIntensity: 0.9, roughness: 0.3, metalness: 0.35, transparent: true, opacity: 0.85, side: THREE.FrontSide,
      polygonOffset: true, polygonOffsetFactor: -1.0, polygonOffsetUnits: -1.0
    });
    const hexFaceBackMat = new THREE.MeshStandardMaterial({
      color: 0x0d2436, emissive: 0x081523, emissiveIntensity: 0.35, roughness: 0.8, metalness: 0.05, transparent: true, opacity: 0.1, side: THREE.BackSide,
      polygonOffset: true, polygonOffsetFactor: 1.0, polygonOffsetUnits: 1.0
    });
    const pentFaceFrontMat = new THREE.MeshStandardMaterial({
      color: 0xffcb88, emissive: 0x5a2b0a, emissiveIntensity: 0.9, roughness: 0.35, metalness: 0.25, transparent: true, opacity: 0.8, side: THREE.FrontSide,
      polygonOffset: true, polygonOffsetFactor: -1.0, polygonOffsetUnits: -1.0
    });
    const pentFaceBackMat = new THREE.MeshStandardMaterial({
      color: 0x331302, emissive: 0x160800, emissiveIntensity: 0.4, roughness: 0.85, metalness: 0.05, transparent: true, opacity: 0.1, side: THREE.BackSide,
      polygonOffset: true, polygonOffsetFactor: 1.0, polygonOffsetUnits: 1.0
    });

    // faint spherical shell for a "barrier" feel
    const shell = new THREE.Mesh(
      new THREE.SphereGeometry(RADIUS*1.001, 128, 128),
      new THREE.MeshStandardMaterial({ color:0x0a2235, transparent:true, opacity:0.12, roughness:0.6, metalness:0.1 })
    );
    group.add(shell);

    let pentCount = 0, hexCount = 0, anomalies = 0;
    const polygons = []; // To store data for dynamic updates

    for (let vi = 0; vi < baseGeo.attributes.position.count; vi++) {
      const faces = vertexToFaces.get(vi);
      if (!faces || faces.length < 5) { anomalies++; continue; } // should not happen on closed sphere

      const orderedFaces = sortFacesAroundVertex(vi);
      const pts = orderedFaces.map(fi => faceCentroids[fi]);

      const isPent = faces.length === 5;
      const isHex  = faces.length === 6;
      if (isPent) pentCount++; else if (isHex) hexCount++; else anomalies++;

      const faceCenter = new THREE.Vector3();
      for (const pt of pts) { faceCenter.add(pt); }
      faceCenter.multiplyScalar(1 / pts.length).normalize().multiplyScalar(RADIUS);

      const triPositions = new Float32Array(pts.length * 9);
      for (let i = 0; i < pts.length; i++) {
        const curr = pts[i];
        const next = pts[(i + 1) % pts.length];
        const off = i * 9;
        triPositions[off] = faceCenter.x;
        triPositions[off + 1] = faceCenter.y;
        triPositions[off + 2] = faceCenter.z;
        triPositions[off + 3] = curr.x;
        triPositions[off + 4] = curr.y;
        triPositions[off + 5] = curr.z;
        triPositions[off + 6] = next.x;
        triPositions[off + 7] = next.y;
        triPositions[off + 8] = next.z;
      }
      const faceGeom = new THREE.BufferGeometry();
      faceGeom.setAttribute('position', new THREE.BufferAttribute(triPositions, 3));
      faceGeom.computeVertexNormals();

      const frontMesh = new THREE.Mesh(faceGeom, isPent ? pentFaceFrontMat : hexFaceFrontMat);
      const backMesh = new THREE.Mesh(faceGeom, isPent ? pentFaceBackMat : hexFaceBackMat);
      backMesh.renderOrder = 0;
      frontMesh.renderOrder = 1;
      group.add(backMesh);
      group.add(frontMesh);

      const geom = new THREE.BufferGeometry();
      const arr = new Float32Array(pts.length * 3);
      for (let i = 0; i < pts.length; i++) { arr[3*i] = pts[i].x; arr[3*i+1] = pts[i].y; arr[3*i+2] = pts[i].z; }
      geom.setAttribute('position', new THREE.BufferAttribute(arr, 3));
      const loop = new THREE.LineLoop(geom, isPent ? pentMat : hexMat);
      loop.renderOrder = 4;
      group.add(loop);

      polygons.push({
        line: loop,
        normal: faceCenter.clone().normalize(),
        isPent: isPent,
      });
    }

    // ===== Self tests =====
    clearTests();
    report('Modules loaded', !!THREE && !!OrbitControls);
    report('Renderer created', !!renderer && !!renderer.domElement);
    report('Triangle faces found', faceCentroids.length > 0, `n=${faceCentroids.length}`);
    report('Pentagon count is 12', pentCount === 12, `found=${pentCount}`);
    report('No anomalies (valence != 5 or 6)', anomalies === 0, `anomalies=${anomalies}`);

    // ===== animation =====
    let t = 0;
    const camWorldPos = new THREE.Vector3();

    function animate(){
      requestAnimationFrame(animate);
      t += 0.0025;
      group.rotation.y = t * 0.35;
      group.rotation.x = Math.sin(t*0.5) * 0.05;
      controls.update();

      camera.getWorldPosition(camWorldPos);
      const groupWorldPos = group.position;
      const viewDir = camWorldPos.sub(groupWorldPos).normalize();

      for (const poly of polygons) {
        const worldNormal = poly.normal.clone().applyQuaternion(group.quaternion);
        const dot = worldNormal.dot(viewDir);

        if (dot > 0) { // Facing towards camera (front side)
          poly.line.material = poly.isPent ? pentMat : hexMat;
        } else { // Facing away from camera (back side)
          poly.line.material = poly.isPent ? pentMatBack : hexMatBack;
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>

  <script>
    // Friendly hints for common pitfalls
    (function(){
      const canvas = document.createElement('canvas');
      if (!canvas.getContext('webgl2') && !canvas.getContext('webgl')) {
        console.warn('[Hint] このブラウザ/環境では WebGL が無効なためレンダリングできません。ブラウザ設定やGPUドライバをご確認ください。');
      }
      if (location.protocol === 'file:') {
        console.info('[Hint] file:// で開いても動きますが、CORSや拡張機能の干渉があると失敗することがあります。うまくいかない場合は簡易HTTPサーバで開いてください (例: `python3 -m http.server`).');
      }
    })();
  </script>
</body>
</html>
