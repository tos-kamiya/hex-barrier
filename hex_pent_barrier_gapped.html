<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gapped Hex Barrier – Regular</title>
  <style>
    html,body{height:100%;margin:0;background:#05070a;color:#e6eef8;font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"}
    #app{position:fixed;inset:0}
    .hud{position:fixed;left:12px;bottom:12px;font-size:12px;opacity:.85;line-height:1.5}
    .tests{position:fixed;right:12px;top:12px;background:#0b1420cc;border:1px solid #1e3350;border-radius:10px;padding:10px 12px;font-size:12px;box-shadow:0 6px 20px #00000055}
    .tests h3{margin:.2em 0 .4em 0;font-size:12px;font-weight:700;color:#cfe8ff}
    .tests ul{list-style:none;margin:0;padding:0}
    .tests li{margin:.2em 0;padding:0}
    .ok{color:#9ff29f}
    .ng{color:#ffb3b3}
    a{color:#a8d1ff}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">隙間のある六角形バリア（正六角形を維持）<br/>クリック＆ドラッグで視点回転（ホイールでズーム）</div>
  <div class="tests" id="tests"><h3>Self‑Tests</h3><ul id="test-list"><li>Running…</li></ul></div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // ===== helpers for inline tests =====
    const testsEl = document.getElementById('test-list');
    function report(name, pass, detail=""){
      const li = document.createElement('li');
      li.className = pass ? 'ok' : 'ng';
      li.textContent = `${pass ? '✔' : '✖'} ${name}${detail ? ' — ' + detail : ''}`;
      testsEl.appendChild(li);
      if(!pass){ console.error('[TEST FAIL]', name, detail); }
    }
    function clearTests(){ testsEl.innerHTML = ''; }

    // ===== scene =====
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('app').appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 6);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // lighting
    const light1 = new THREE.DirectionalLight(0xffffff, 0.8); light1.position.set(3,2,4); scene.add(light1);
    const amb = new THREE.AmbientLight(0x88aaff, 0.35); scene.add(amb);

    // ===== parameters =====
    const RADIUS = 2.0;
    const DETAIL = 3;
    const GAP_AMOUNT = 0.3; // 20% gap
    const PULL_STRENGTH = 0.08; // Max move amount
    const PULL_RADIUS = 1.8;   // Radius of effect around pentagons

    // ===== build geodesic sphere (triangles) =====
    const baseGeo = new THREE.IcosahedronGeometry(RADIUS, DETAIL);
    baseGeo.computeVertexNormals();

    {
      const pos = baseGeo.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const v = new THREE.Vector3().fromBufferAttribute(pos, i).normalize().multiplyScalar(RADIUS);
        pos.setXYZ(i, v.x, v.y, v.z);
      }
      pos.needsUpdate = true;
    }

    const posAttr = baseGeo.attributes.position;
    const vertices = [];
    let index = baseGeo.index ? Array.from(baseGeo.index.array) : null;

    if (index) {
      for (let i = 0; i < posAttr.count; i++) {
        vertices.push(new THREE.Vector3().fromBufferAttribute(posAttr, i));
      }
    } else {
      const keyToIndex = new Map();
      index = [];
      for (let i = 0; i < posAttr.count; i++) {
        const v = new THREE.Vector3().fromBufferAttribute(posAttr, i);
        const key = `${v.x.toFixed(6)},${v.y.toFixed(6)},${v.z.toFixed(6)}`;
        let mapped = keyToIndex.get(key);
        if (mapped === undefined) {
          mapped = vertices.length;
          keyToIndex.set(key, mapped);
          vertices.push(v);
        }
        index.push(mapped);
      }
    }

    const getV = (i) => vertices[i].clone();

    const faceCentroids = [];
    for (let f = 0; f < index.length; f += 3) {
      const a = getV(index[f]);
      const b = getV(index[f+1]);
      const c = getV(index[f+2]);
      const centroid = new THREE.Vector3().add(a).add(b).add(c).multiplyScalar(1/3).normalize().multiplyScalar(RADIUS);
      faceCentroids.push(centroid);
    }

    const vertexToFaces = new Map();
    for (let fi = 0, tri = 0; fi < index.length; fi += 3, tri++) {
      for (let k = 0; k < 3; k++) {
        const vi = index[fi + k];
        if (!vertexToFaces.has(vi)) vertexToFaces.set(vi, []);
        vertexToFaces.get(vi).push(tri);
      }
    }

    const sortFacesAroundVertex = (vertexIndex) => {
      const v = getV(vertexIndex).clone().normalize();
      const faces = vertexToFaces.get(vertexIndex);
      const up = v.clone();
      const tmp = Math.abs(up.y) < 0.9 ? new THREE.Vector3(0,1,0) : new THREE.Vector3(1,0,0);
      const tangent = new THREE.Vector3().crossVectors(tmp, up).normalize();
      const bitangent = new THREE.Vector3().crossVectors(up, tangent).normalize();
      const items = faces.map(fi => {
        const c = faceCentroids[fi];
        const d = c.clone().sub(up.clone().multiplyScalar(c.clone().dot(up)));
        const x = d.dot(tangent);
        const y = d.dot(bitangent);
        const ang = Math.atan2(y, x);
        return { fi, ang };
      });
      items.sort((a,b) => a.ang - b.ang);
      return items.map(it => it.fi);
    };

    // ===== Create polygons (dual mesh) =====
    const group = new THREE.Group();
    scene.add(group);

    const hexMat = new THREE.LineBasicMaterial({ color: 0x89f0ff });
    const hexMatBack = new THREE.LineBasicMaterial({ color: 0x2a484d });

    const hexFaceFrontMat = new THREE.MeshStandardMaterial({
      color: 0x52e4ff, emissive: 0x154d72, emissiveIntensity: 0.9, roughness: 0.3, metalness: 0.35, transparent: true, opacity: 0.85, side: THREE.FrontSide,
      polygonOffset: true, polygonOffsetFactor: -1.0, polygonOffsetUnits: -1.0
    });
    const hexFaceBackMat = new THREE.MeshStandardMaterial({
      color: 0x0d2436, emissive: 0x081523, emissiveIntensity: 0.35, roughness: 0.8, metalness: 0.05, transparent: true, opacity: 0.1, side: THREE.BackSide,
      polygonOffset: true, polygonOffsetFactor: 1.0, polygonOffsetUnits: 1.0
    });

    const shell = new THREE.Mesh(
      new THREE.SphereGeometry(RADIUS*1.001, 128, 128),
      new THREE.MeshStandardMaterial({ color:0x0a2235, transparent:true, opacity:0.12, roughness:0.6, metalness:0.1 })
    );
    group.add(shell);

    // --- Pass 1: Find pentagon centers ---
    const pentagonCenters = [];
    for (let vi = 0; vi < baseGeo.attributes.position.count; vi++) {
      const faces = vertexToFaces.get(vi);
      if (!faces || faces.length !== 5) continue;
      const orderedFaces = sortFacesAroundVertex(vi);
      const pts = orderedFaces.map(fi => faceCentroids[fi]);
      const faceCenter = new THREE.Vector3();
      for (const pt of pts) { faceCenter.add(pt); }
      faceCenter.multiplyScalar(1 / pts.length);
      pentagonCenters.push(faceCenter);
    }

    // --- Pass 2: Draw hexagons, shifted towards nearest pentagon ---
    let pentCount = 0, hexCount = 0, anomalies = 0;
    const polygons = [];

    for (let vi = 0; vi < baseGeo.attributes.position.count; vi++) {
      const faces = vertexToFaces.get(vi);
      if (!faces || faces.length < 5) { anomalies++; continue; }

      const isPent = faces.length === 5;
      if (isPent) {
        pentCount++;
        continue; // Skip drawing pentagons
      }
      
      const isHex  = faces.length === 6;
      if (isHex) hexCount++; else anomalies++;

      const orderedFaces = sortFacesAroundVertex(vi);
      const original_pts = orderedFaces.map(fi => faceCentroids[fi]);
      let faceCenter = new THREE.Vector3();
      for (const pt of original_pts) { faceCenter.add(pt); }
      faceCenter.multiplyScalar(1 / original_pts.length);

      // --- Regenerate as a regular hexagon on its tangent plane ---
      const normal = faceCenter.clone().normalize();
      const tmp_up = Math.abs(normal.y) < 0.9 ? new THREE.Vector3(0,1,0) : new THREE.Vector3(1,0,0);
      const tangent = new THREE.Vector3().crossVectors(tmp_up, normal).normalize();
      const bitangent = new THREE.Vector3().crossVectors(normal, tangent).normalize();

      let avgRadius = 0;
      for (const pt of original_pts) { avgRadius += pt.distanceTo(faceCenter); }
      avgRadius /= original_pts.length;

      let pts = [];
      for (let i = 0; i < 6; i++) {
          const angle = Math.PI / 3 * i;
          const x = avgRadius * Math.cos(angle);
          const y = avgRadius * Math.sin(angle);
          const new_pt = faceCenter.clone()
              .add(tangent.clone().multiplyScalar(x))
              .add(bitangent.clone().multiplyScalar(y));
          pts.push(new_pt);
      }

      // --- Shift towards nearest pentagon ---
      if (pentagonCenters.length > 0) {
        let nearestPentCenter = null;
        let min_dist_sq = Infinity;
        for (const p_center of pentagonCenters) {
            const dist_sq = faceCenter.distanceToSquared(p_center);
            if (dist_sq < min_dist_sq) {
                min_dist_sq = dist_sq;
                nearestPentCenter = p_center;
            }
        }
        
        const dist = Math.sqrt(min_dist_sq);
        if (dist < PULL_RADIUS) {
            const pull_factor = 1.0 - (dist / PULL_RADIUS);
            const move_vec = nearestPentCenter.clone().sub(faceCenter).normalize().multiplyScalar(PULL_STRENGTH * pull_factor);
            pts = pts.map(p => p.add(move_vec));
            faceCenter.add(move_vec);
        }
      }

      // --- Create gaps using scaling ---
      const scale_factor = 1.0 - GAP_AMOUNT;
      pts = pts.map(pt => faceCenter.clone().add(pt.clone().sub(faceCenter).multiplyScalar(scale_factor)));
      
      // --- Project points back to sphere surface ---
      pts = pts.map(p => p.normalize().multiplyScalar(RADIUS));
      
      const visualCenter = new THREE.Vector3();
      for (const pt of pts) { visualCenter.add(pt); }
      visualCenter.multiplyScalar(1 / pts.length).normalize().multiplyScalar(RADIUS);

      // --- Drawing logic ---
      const triPositions = new Float32Array(pts.length * 9);
      for (let i = 0; i < pts.length; i++) {
        const curr = pts[i];
        const next = pts[(i + 1) % pts.length];
        const off = i * 9;
        triPositions.set([visualCenter.x, visualCenter.y, visualCenter.z], off);
        triPositions.set([curr.x, curr.y, curr.z], off + 3);
        triPositions.set([next.x, next.y, next.z], off + 6);
      }
      const faceGeom = new THREE.BufferGeometry();
      faceGeom.setAttribute('position', new THREE.BufferAttribute(triPositions, 3));
      faceGeom.computeVertexNormals();

      const frontMesh = new THREE.Mesh(faceGeom, hexFaceFrontMat);
      const backMesh = new THREE.Mesh(faceGeom, hexFaceBackMat);
      backMesh.renderOrder = 0;
      frontMesh.renderOrder = 1;
      group.add(backMesh, frontMesh);

      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const loop = new THREE.LineLoop(geom, hexMat);
      loop.renderOrder = 4;
      group.add(loop);

      polygons.push({
        line: loop,
        normal: visualCenter.clone().normalize(),
      });
    }

    // ===== Self tests =====
    clearTests();
    report('Modules loaded', !!THREE && !!OrbitControls);
    report('Renderer created', !!renderer && !!renderer.domElement);
    report('Hexagons drawn', hexCount > 0, `n=${hexCount}`);
    report('Pentagons skipped', pentCount === 12, `found=${pentCount}`);
    report('No anomalies (valence != 5 or 6)', anomalies === 0, `anomalies=${anomalies}`);

    // ===== animation =====
    let t = 0;
    const camWorldPos = new THREE.Vector3();

    function animate(){
      requestAnimationFrame(animate);
      t += 0.0025;
      group.rotation.y = t * 0.35;
      group.rotation.x = Math.sin(t*0.5) * 0.05;
      controls.update();

      camera.getWorldPosition(camWorldPos);
      const groupWorldPos = group.position;
      const viewDir = camWorldPos.sub(groupWorldPos).normalize();

      for (const poly of polygons) {
        const worldNormal = poly.normal.clone().applyQuaternion(group.quaternion);
        const dot = worldNormal.dot(viewDir);

        if (dot > 0) { // Facing towards camera (front side)
          poly.line.material = hexMat;
        } else { // Facing away from camera (back side)
          poly.line.material = hexMatBack;
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>

  <script>
    // Friendly hints for common pitfalls
    (function(){
      const canvas = document.createElement('canvas');
      if (!canvas.getContext('webgl2') && !canvas.getContext('webgl')) {
        console.warn('[Hint] このブラウザ/環境では WebGL が無効なためレンダリングできません。ブラウザ設定やGPUドライバをご確認ください。');
      }
      if (location.protocol === 'file:') {
        console.info('[Hint] file:// で開いても動きますが、CORSや拡張機能の干渉があると失敗することがあります。うまくいかない場合は簡易HTTPサーバで開いてください (例: `python3 -m http.server`).');
      }
    })();
  </script>
</body>
</html>
