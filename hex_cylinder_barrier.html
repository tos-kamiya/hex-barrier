<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hex Cylinder Barrier – Three.js Demo</title>
  <style>
    html,body{height:100%;margin:0;background:#05070a;color:#e6eef8;font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"}
    #app{position:fixed;inset:0}
    .hud{position:fixed;left:12px;bottom:12px;font-size:12px;opacity:.85;line-height:1.5}
    .tests{position:fixed;right:12px;top:12px;background:#0b1420cc;border:1px solid #1e3350;border-radius:10px;padding:10px 12px;font-size:12px;box-shadow:0 6px 20px #00000055}
    .tests h3{margin:.2em 0 .4em 0;font-size:12px;font-weight:700;color:#cfe8ff}
    .tests ul{list-style:none;margin:0;padding:0}
    .tests li{margin:.2em 0;padding:0}
    .ok{color:#9ff29f}
    .ng{color:#ffb3b3}
    a{color:#a8d1ff}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">六角形を円筒状に配置した“バリア”ネット<br/>クリック＆ドラッグで視点回転（ホイールでズーム）</div>
  <div class="tests" id="tests"><h3>Self‑Tests</h3><ul id="test-list"><li>Running…</li></ul></div>

  <script type="module">
    // NOTE: modules loaded from esm.sh CDN so dependencies resolve without import maps
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // ===== helpers for inline tests =====
    const testsEl = document.getElementById('test-list');
    function report(name, pass, detail=""){
      const li = document.createElement('li');
      li.className = pass ? 'ok' : 'ng';
      li.textContent = `${pass ? '✔' : '✖'} ${name}${detail ? ' — ' + detail : ''}`;
      testsEl.appendChild(li);
      if(!pass){ console.error('[TEST FAIL]', name, detail); }
    }
    function clearTests(){ testsEl.innerHTML = ''; }

    // ===== scene =====
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('app').appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 8);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // lighting
    const light1 = new THREE.DirectionalLight(0xffffff, 0.8); light1.position.set(3,2,4); scene.add(light1);
    const amb = new THREE.AmbientLight(0x88aaff, 0.35); scene.add(amb);

    // ===== parameters =====
    const SPHERE_RADIUS = 2.2;
    const HEX_SIZE = 0.3;
    const GRID_WIDTH = 2 * Math.PI * SPHERE_RADIUS;
    const GRID_HEIGHT = Math.PI * SPHERE_RADIUS;
    
    const hexHeight = 2 * HEX_SIZE;
    const hexWidth = Math.sqrt(3) * HEX_SIZE;
    const NUM_DIV_X = Math.floor(GRID_WIDTH / hexWidth);
    const MIN_HEX_PER_ROW = 6;
    const MIN_HEX_HEIGHT_SCALE = 0.05;
    const MAX_VERTICAL_STRETCH = 3.0;
    const SIN60 = Math.sin(Math.PI / 3);

    // ===== Create polygons =====
    const group = new THREE.Group();
    scene.add(group);

    const hexMat = new THREE.LineBasicMaterial({ color: 0x89f0ff });
    const hexMatBack = new THREE.LineBasicMaterial({ color: 0x2a484d });

    const hexFaceFrontMat = new THREE.MeshStandardMaterial({
      color: 0x52e4ff, emissive: 0x154d72, emissiveIntensity: 0.9, roughness: 0.3, metalness: 0.35, transparent: true, opacity: 0.85, side: THREE.FrontSide,
      polygonOffset: true, polygonOffsetFactor: -1.0, polygonOffsetUnits: -1.0
    });
    const hexFaceBackMat = new THREE.MeshStandardMaterial({
      color: 0x0d2436, emissive: 0x081523, emissiveIntensity: 0.35, roughness: 0.8, metalness: 0.05, transparent: true, opacity: 0.1, side: THREE.BackSide,
      polygonOffset: true, polygonOffsetFactor: 1.0, polygonOffsetUnits: 1.0
    });

    let hexCount = 0;
    const polygons = [];

    function computeRowParameters(lat) {
      const cosine = Math.max(0, Math.cos(lat));
      const approx = NUM_DIV_X * cosine;
      const numHex = Math.max(MIN_HEX_PER_ROW, Math.floor(approx));
      const horizScale = numHex > 0 ? NUM_DIV_X / numHex : 1.0;
      const baseHeightScale = (1.0 - MIN_HEX_HEIGHT_SCALE) * cosine + MIN_HEX_HEIGHT_SCALE;
      const boostTarget = horizScale / Math.max(baseHeightScale, 1e-3);
      const boost = Math.min(MAX_VERTICAL_STRETCH, boostTarget);
      const verticalScale = baseHeightScale * boost;
      return { numHex, horizScale, baseHeightScale, verticalScale };
    }

    function latFromY(yFlat) {
      return (yFlat / (GRID_HEIGHT / 2)) * (Math.PI / 2);
    }

    function solveStep(currentY) {
      let lat = latFromY(currentY);
      let metrics = computeRowParameters(lat);
      let step = (hexHeight * 0.75) * metrics.verticalScale;
      for (let iter = 0; iter < 3; iter++) {
        const nextLat = latFromY(currentY + step);
        const nextMetrics = computeRowParameters(nextLat);
        const target = (hexHeight * 0.75) * nextMetrics.verticalScale;
        if (!isFinite(target) || target <= 0) break;
        if (Math.abs(target - step) < 1e-4) {
          step = target;
          break;
        }
        step = (step + target) * 0.5;
      }
      return step;
    }

    function createHexRow(rowInfo) {
      const y_flat_center = rowInfo.y;
      const center_lat = (y_flat_center / (GRID_HEIGHT / 2)) * (Math.PI / 2);
      if (Math.abs(center_lat) > Math.PI / 2) return;

      const { numHex, horizScale, baseHeightScale, verticalScale } = computeRowParameters(center_lat);
      const num_hex_in_row = numHex;
      if (num_hex_in_row <= 0) return;

      let appliedVerticalScale = verticalScale;
      if (rowInfo.availableHalfSpan && rowInfo.availableHalfSpan > 0) {
        const maxFromGap = rowInfo.availableHalfSpan / (HEX_SIZE * SIN60);
        if (maxFromGap > 0) {
          appliedVerticalScale = Math.min(appliedVerticalScale, maxFromGap);
          if (maxFromGap >= baseHeightScale) {
            appliedVerticalScale = Math.max(appliedVerticalScale, baseHeightScale);
          }
        }
      }
      appliedVerticalScale = Math.max(appliedVerticalScale, MIN_HEX_HEIGHT_SCALE);

      const rowParity = Math.abs(rowInfo.index) % 2;
      const offset = rowParity * 0.5;

      for (let q = 0; q < num_hex_in_row; q++) {
        const x_flat_center = ((q + offset) / num_hex_in_row) * GRID_WIDTH;

        const pts = [];
        for (let i = 0; i < 6; i++) {
          const angle = Math.PI / 3 * i;
          const y_offset = HEX_SIZE * Math.sin(angle);
          const scaled_y_offset = y_offset * appliedVerticalScale * 1.2;
          const x_offset = HEX_SIZE * Math.cos(angle) * horizScale;

          const vx_flat_pt = x_flat_center + x_offset;
          const vy_flat_pt = y_flat_center + scaled_y_offset;

          const lon = (vx_flat_pt / GRID_WIDTH) * Math.PI * 2;
          const lat = (vy_flat_pt / (GRID_HEIGHT / 2)) * (Math.PI / 2);

          if (Math.abs(lat) > Math.PI / 2) continue;

          const x_3d = SPHERE_RADIUS * Math.cos(lat) * Math.cos(lon);
          const y_3d = SPHERE_RADIUS * Math.sin(lat);
          const z_3d = SPHERE_RADIUS * Math.cos(lat) * Math.sin(lon);
          pts.push(new THREE.Vector3(x_3d, y_3d, z_3d));
        }

        if (pts.length < 6) continue;

        const faceCenter = new THREE.Vector3();
        pts.forEach(p => faceCenter.add(p));
        faceCenter.divideScalar(pts.length);
        hexCount++;

        const triPositions = new Float32Array(pts.length * 9);
        for (let i = 0; i < pts.length; i++) {
          const curr = pts[i];
          const next = pts[(i + 1) % pts.length];
          const off = i * 9;
          triPositions.set([faceCenter.x, faceCenter.y, faceCenter.z], off);
          triPositions.set([curr.x, curr.y, curr.z], off + 3);
          triPositions.set([next.x, next.y, next.z], off + 6);
        }
        const faceGeom = new THREE.BufferGeometry();
        faceGeom.setAttribute('position', new THREE.BufferAttribute(triPositions, 3));
        faceGeom.computeVertexNormals();

        const frontMesh = new THREE.Mesh(faceGeom, hexFaceFrontMat);
        const backMesh = new THREE.Mesh(faceGeom, hexFaceBackMat);
        backMesh.renderOrder = 0;
        frontMesh.renderOrder = 1;
        group.add(backMesh, frontMesh);

        const geom = new THREE.BufferGeometry().setFromPoints(pts);
        const loop = new THREE.LineLoop(geom, hexMat);
        loop.renderOrder = 4;
        group.add(loop);

        const normal = faceCenter.clone().normalize();
        polygons.push({ line: loop, normal: normal });
      }
    }

    // --- Cumulative placement logic ---
    const rows = [{ y: 0, index: 0 }];
    let positive_y = 0;
    let negative_y = 0;

    const HALF_GRID_HEIGHT = GRID_HEIGHT / 2;
    const EPSILON = 1e-4;
    const MAX_ROW_ITER = 256;

    for (let r = 1; r < MAX_ROW_ITER; r++) {
      let step_p = solveStep(positive_y);

      if (positive_y + step_p >= HALF_GRID_HEIGHT - EPSILON) {
        step_p = (HALF_GRID_HEIGHT - EPSILON) - positive_y;
      }

      if (step_p <= 0) break;

      positive_y += step_p;
      if (positive_y >= HALF_GRID_HEIGHT) break;
      rows.push({ y: positive_y, index: r });

      const step_n = step_p;
      negative_y -= step_n;
      if (negative_y <= -HALF_GRID_HEIGHT) break;
      rows.push({ y: negative_y, index: -r });

      if (positive_y >= HALF_GRID_HEIGHT - EPSILON) break;
    }

    rows.sort((a, b) => a.y - b.y);

    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      const distanceToPole = HALF_GRID_HEIGHT - Math.abs(row.y);
      const gapUp = i < rows.length - 1 ? rows[i + 1].y - row.y : distanceToPole;
      const gapDown = i > 0 ? row.y - rows[i - 1].y : distanceToPole;
      const halfGapUp = i < rows.length - 1 ? gapUp * 0.5 : gapUp;
      const halfGapDown = i > 0 ? gapDown * 0.5 : gapDown;
      row.availableHalfSpan = Math.max(0, Math.min(halfGapUp, halfGapDown));
    }

    rows.forEach(createHexRow);

    // ===== Self tests =====
    clearTests();
    report('Modules loaded', !!THREE && !!OrbitControls);
    report('Renderer created', !!renderer && !!renderer.domElement);
    report('Hexagons created', hexCount > 0, `n=${hexCount}`);

    // ===== animation =====
    let t = 0;
    const camWorldPos = new THREE.Vector3();

    function animate(){
      requestAnimationFrame(animate);
      t += 0.0025;
      group.rotation.y = t * 0.2;
      group.rotation.x = t * 0.1;
      controls.update();

      camera.getWorldPosition(camWorldPos);
      const groupWorldPos = group.position;
      const viewDir = camWorldPos.sub(groupWorldPos).normalize();

      for (const poly of polygons) {
        const worldNormal = poly.normal.clone().applyQuaternion(group.quaternion);
        const dot = worldNormal.dot(viewDir);

        if (dot > 0) { // Facing towards camera (front side)
          poly.line.material = hexMat;
        } else { // Facing away from camera (back side)
          poly.line.material = hexMatBack;
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>

  <script>
    // Friendly hints for common pitfalls
    (function(){
      const canvas = document.createElement('canvas');
      if (!canvas.getContext('webgl2') && !canvas.getContext('webgl')) {
        console.warn('[Hint] このブラウザ/環境では WebGL が無効なためレンダリングできません。ブラウザ設定やGPUドライバをご確認ください。');
      }
      if (location.protocol === 'file:') {
        console.info('[Hint] file:// で開いても動きますが、CORSや拡張機能の干渉があると失敗することがあります。うまくいかない場合は簡易HTTPサーバで開いてください (例: `python3 -m http.server`).');
      }
    })();
  </script>
</body>
</html>
