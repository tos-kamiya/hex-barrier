<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hex Cylinder Tapered Barrier – Three.js Demo</title>
  <style>
    html,body{height:100%;margin:0;background:#05070a;color:#e6eef8;font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"}
    #app{position:fixed;inset:0}
    .hud{position:fixed;left:12px;bottom:12px;font-size:12px;opacity:.85;line-height:1.5}
    .tests{position:fixed;right:12px;top:12px;background:#0b1420cc;border:1px solid #1e3350;border-radius:10px;padding:10px 12px;font-size:12px;box-shadow:0 6px 20px #00000055}
    .tests h3{margin:.2em 0 .4em 0;font-size:12px;font-weight:700;color:#cfe8ff}
    .tests ul{list-style:none;margin:0;padding:0}
    .tests li{margin:.2em 0;padding:0}
    .ok{color:#9ff29f}
    .ng{color:#ffb3b3}
    a{color:#a8d1ff}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">円筒上の六角形グリッドを極方向へ絞り込んだ“バリア”ネット<br/>クリック＆ドラッグで視点回転（ホイールでズーム）</div>
  <div class="tests" id="tests"><h3>Self‑Tests</h3><ul id="test-list"><li>Running…</li></ul></div>

  <script type="module">
    // NOTE: modules loaded from esm.sh CDN so dependencies resolve without import maps
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // ===== helpers for inline tests =====
    const testsEl = document.getElementById('test-list');
    function report(name, pass, detail=""){
      const li = document.createElement('li');
      li.className = pass ? 'ok' : 'ng';
      li.textContent = `${pass ? '✔' : '✖'} ${name}${detail ? ' — ' + detail : ''}`;
      testsEl.appendChild(li);
      if(!pass){ console.error('[TEST FAIL]', name, detail); }
    }
    function clearTests(){ testsEl.innerHTML = ''; }

    // ===== scene =====
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('app').appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 8);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // lighting
    const light1 = new THREE.DirectionalLight(0xffffff, 0.8); light1.position.set(3,2,4); scene.add(light1);
    const amb = new THREE.AmbientLight(0x88aaff, 0.35); scene.add(amb);

    // ===== parameters =====
    const SPHERE_RADIUS = 2.2;
    const HEX_SIZE = 0.3;

    const hexHeight = 2 * HEX_SIZE;
    const hexWidth = Math.sqrt(3) * HEX_SIZE;
    const MIN_HEX_PER_ROW = 6;

    const equatorCircumference = 2 * Math.PI * SPHERE_RADIUS;
    const NUM_HEX_AROUND = Math.max(MIN_HEX_PER_ROW, Math.round(equatorCircumference / hexWidth));
    const ROW_STRIDE = hexHeight * 0.75;
    const deltaLat = ROW_STRIDE / SPHERE_RADIUS;
    const LAT_LIMIT = (Math.PI / 2) * 0.98;
    const MAX_ROW_INDEX = Math.ceil(LAT_LIMIT / deltaLat);

    // ===== Create polygons =====
    const group = new THREE.Group();
    scene.add(group);

    const hexMat = new THREE.LineBasicMaterial({ color: 0x89f0ff });
    const hexMatBack = new THREE.LineBasicMaterial({ color: 0x2a484d });

    const hexFaceFrontMat = new THREE.MeshStandardMaterial({
      color: 0x52e4ff, emissive: 0x154d72, emissiveIntensity: 0.9, roughness: 0.3, metalness: 0.35, transparent: true, opacity: 0.85, side: THREE.FrontSide,
      polygonOffset: true, polygonOffsetFactor: -1.0, polygonOffsetUnits: -1.0
    });
    const hexFaceBackMat = new THREE.MeshStandardMaterial({
      color: 0x0d2436, emissive: 0x081523, emissiveIntensity: 0.35, roughness: 0.8, metalness: 0.05, transparent: true, opacity: 0.1, side: THREE.BackSide,
      polygonOffset: true, polygonOffsetFactor: 1.0, polygonOffsetUnits: 1.0
    });

    let hexCount = 0;
    const polygons = [];
    const tmpOffset = new THREE.Vector3();

    function createHexRow(rowInfo) {
      const center_lat = rowInfo.lat;
      const cosine = Math.max(0, Math.cos(center_lat));
      if (cosine <= 0) return;

      const circumference = equatorCircumference * cosine;
      const horizScale = circumference / Math.max(NUM_HEX_AROUND * hexWidth, 1e-6);
      if (!isFinite(horizScale) || horizScale <= 0) return;
      const verticalScale = THREE.MathUtils.clamp(Math.pow(Math.max(horizScale, 1e-3), 0.9), 0.1, 1.0);

      const num_hex_in_row = NUM_HEX_AROUND;
      const rowParity = Math.abs(rowInfo.index) % 2;
      const offset = rowParity * 0.5;

      for (let q = 0; q < num_hex_in_row; q++) {
        const fraction = (q + offset) / num_hex_in_row;
        const lon_center = fraction * Math.PI * 2;

        const cosLon = Math.cos(lon_center);
        const sinLon = Math.sin(lon_center);
        const cosLat = Math.cos(center_lat);
        const sinLat = Math.sin(center_lat);

        const centerVec = new THREE.Vector3(
          SPHERE_RADIUS * cosLat * cosLon,
          SPHERE_RADIUS * sinLat,
          SPHERE_RADIUS * cosLat * sinLon
        );

        const normalVec = centerVec.clone().normalize();
        const arbitrary = Math.abs(normalVec.y) > 0.98 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 1, 0);
        const east = new THREE.Vector3().crossVectors(arbitrary, normalVec).normalize();
        if (east.lengthSq() < 1e-6) {
          east.set(1, 0, 0);
        }
        const north = new THREE.Vector3().crossVectors(normalVec, east).normalize();

        const pts = [];
        for (let i = 0; i < 6; i++) {
          const angle = Math.PI / 3 * i;
          const y_offset = HEX_SIZE * Math.sin(angle) * verticalScale;
          const x_offset = HEX_SIZE * Math.cos(angle) * horizScale;

          tmpOffset.copy(east).multiplyScalar(x_offset)
            .addScaledVector(north, y_offset);

          const vertex = centerVec.clone().add(tmpOffset).normalize().multiplyScalar(SPHERE_RADIUS);
          pts.push(vertex);
        }

        if (pts.length < 3) continue;

        const faceCenter = new THREE.Vector3();
        for (const p of pts) faceCenter.add(p);
        faceCenter.divideScalar(pts.length);
        hexCount++;

        const triPositions = new Float32Array(pts.length * 9);
        for (let i = 0; i < pts.length; i++) {
          const curr = pts[i];
          const next = pts[(i + 1) % pts.length];
          const off = i * 9;
          triPositions.set([faceCenter.x, faceCenter.y, faceCenter.z], off);
          triPositions.set([curr.x, curr.y, curr.z], off + 3);
          triPositions.set([next.x, next.y, next.z], off + 6);
        }
        const faceGeom = new THREE.BufferGeometry();
        faceGeom.setAttribute('position', new THREE.BufferAttribute(triPositions, 3));
        faceGeom.computeVertexNormals();

        const frontMesh = new THREE.Mesh(faceGeom, hexFaceFrontMat);
        const backMesh = new THREE.Mesh(faceGeom, hexFaceBackMat);
        backMesh.renderOrder = 0;
        frontMesh.renderOrder = 1;
        group.add(backMesh, frontMesh);

        const geom = new THREE.BufferGeometry().setFromPoints(pts);
        const loop = new THREE.LineLoop(geom, hexMat);
        loop.renderOrder = 4;
        group.add(loop);

        const normal = faceCenter.clone().normalize();
        polygons.push({ line: loop, normal: normal });
      }
    }

    const rows = [];
    for (let idx = -MAX_ROW_INDEX; idx <= MAX_ROW_INDEX; idx++) {
      const latCandidate = idx * deltaLat;
      const clampedLat = THREE.MathUtils.clamp(latCandidate, -LAT_LIMIT, LAT_LIMIT);
      if (rows.length > 0) {
        const prevLat = rows[rows.length - 1].lat;
        if (Math.abs(prevLat - clampedLat) < 1e-5) continue;
      }
      rows.push({ lat: clampedLat, index: idx });
    }

    rows.sort((a, b) => a.lat - b.lat);
    rows.forEach(createHexRow);

    // ===== Self tests =====
    clearTests();
    report('Modules loaded', !!THREE && !!OrbitControls);
    report('Renderer created', !!renderer && !!renderer.domElement);
    report('Hexagons created', hexCount > 0, `n=${hexCount}`);

    // ===== animation =====
    let t = 0;
    const camWorldPos = new THREE.Vector3();

    function animate(){
      requestAnimationFrame(animate);
      t += 0.0025;
      group.rotation.y = t * 0.2;
      group.rotation.x = t * 0.1;
      controls.update();

      camera.getWorldPosition(camWorldPos);
      const groupWorldPos = group.position;
      const viewDir = camWorldPos.sub(groupWorldPos).normalize();

      for (const poly of polygons) {
        const worldNormal = poly.normal.clone().applyQuaternion(group.quaternion);
        const dot = worldNormal.dot(viewDir);

        if (dot > 0) { // Facing towards camera (front side)
          poly.line.material = hexMat;
        } else { // Facing away from camera (back side)
          poly.line.material = hexMatBack;
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>

  <script>
    // Friendly hints for common pitfalls
    (function(){
      const canvas = document.createElement('canvas');
      if (!canvas.getContext('webgl2') && !canvas.getContext('webgl')) {
        console.warn('[Hint] このブラウザ/環境では WebGL が無効なためレンダリングできません。ブラウザ設定やGPUドライバをご確認ください。');
      }
      if (location.protocol === 'file:') {
        console.info('[Hint] file:// で開いても動きますが、CORSや拡張機能の干渉があると失敗することがあります。うまくいかない場合は簡易HTTPサーバで開いてください (例: `python3 -m http.server`).');
      }
    })();
  </script>
</body>
</html>
